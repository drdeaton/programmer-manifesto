# Git

One of the most important tools any developer has is version control. The most popular version control software is Git, and that is what most people in Vex, including Aggie Robotics, use.

## Repositories

A project in Git is called a repository. It is typically the entire contents of a folder containing your program's source code, with a few files excluded. In addition, a repository has a lot of metadata associated with it, particularly the history of changes to the repository, as well as branches and tags. Every repository starts out empty, and all content is saved through these commits.

## Commits

A "commit" is a set of changes applied to a repository, referenced by a hash. Every commit (except the initial commit) has a reference to its parent commit; that is the version of the code immediately before it. For example, if you have the following code:

```cpp
void main() {
  // TODO: Do nothing
}
```

and you change it to this and commit:

```cpp
void main() {
  std::cout << "Hello world!" << std::endl;
}
```

Then the commit is just a pointer to the previous version of the code, as well as metadata saying what was added and removed

```
line 2:
-   // TODO: Do nothing
+   std::cout << "Hello world!" << std::endl;
```

> [!NOTE]
> Multiple commits can have the same parent. We call these commits members of different branches.

Another important concept with commits is immutability. By design, once a commit is made, it cannot be edited, and is always part of the repository. However, this usually isn't a problem

## Branches and Tags

Git has a few different types of named commits, which make it easier to reference a version of the code without remembering a hash. 

The first and most important named commit is `HEAD`. This references the currently active version of the code, be it the latest version on a branch, some old version, or any other version of the code throughout the repository.

Another type of named commit is a branch. A branch name usually tracks the latest commit along the local copy of a specific branch within a repository.

Tags are also a type of named commit. Unlike branches, a tag will always reference the commit where it was created. Tags also form the basis for Github's Releases feature.

## Merging Changes

When 2 branches diverge, it can be a pain to bring together the changes. Fortunately, Git has a tool specifically designed for that: the merge commit. A merge commit is a special type of commit that has 2 parents, so it can apply all of the changes of both branches together. During a merge, there are 2 parent branches to consider: the "base" branch, which is where the new commit is created, and the "incoming" branch. Git will automatically apply all of the changes from the incoming branch to the base branch when it can.

Git can't always do everything on its own, though. Sometimes, the changes on 2 branches will conflict with one another. When this happens, it will require the programmer to manually edit the code before the merge commit can be completed.

> [!WARNING]
> Git is not perfect, and even if it "succeeds" at merging, it is possible for it to splice together code that doesn't work. You, the programmer, are responsible for looking through these changes and ensuring that it all works as expected. Automated testing can help with this.

## Git-flow

For development of ReveilLib, we like to use a specific branching model aimed at ensuring we always have stable code. This model is known as Git-flow. In essence there are 2 main branches:

- The `master` branch holds the latest stable release (not release candidate) code. Code that isn't competition-ready should never be included on this branch.
- The `develop` branch holds feature-complete code awaiting release. This code might contain bugs.
- The `gh-pages` branch contains autogenerated documentation, and its existence should be ignored for the most part. You will never commit or merge directly to this branch, and in fact it actually has no parent in common with any other branch on the repository.

These main branches should *never* get code directly committed to them.

As a general rule, `master` is always behind `develop`.

There are also 3 other types of branches

- Branches of the form `hotfix-<major>.<minor>.<patch>` are for bug fixes on release code
  - These branches branch off of `master`, recieve direct commits to fix bugs, and then merge into `master` then `master` merges into `develop`.
  - When these branches are merged into master, they also come with a new patch version number.
- Branches of the form `release-<major>.<minor>.<patch>` are for major and minor releases
  - These branches branch off of `develop` and recieve direct commits to prepare them for release.
  - Once a `release-` branch is complete, it is merged into `master` and then `master` into `develop`, and a new release is created on `master`.
  - On a release branch, `<patch>` should always be `0`
  - While preparing for release, pre-releases (also known as release candidates) may be built and released based on this branch.
- All other branches are called feature branches
  - Feature branches branch off of `develop`
  - A feature branch has usually 1 specific feature it aims to develop, or otherwise 1 change to functionality, or even just a refactor without a change to functionality
  - Feature branches are merged directly back into `develop` once they are ready.

---

References:
- [A successful Git branching model - nvie.com](https://nvie.com/posts/a-successful-git-branching-model/)